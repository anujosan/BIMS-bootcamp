---
title: "Using R to Visualize and Analyze Data"
output: github_document
---

This session will cover fundamental concepts for creating effective data visualization and will introduce tools and techniques for visualizing large, high-dimensional data using R. We will review fundamental concepts for visually displaying quantitative information, such as using series of small multiples, avoiding "chart-junk," and maximizing the data-ink ratio. We will cover the grammar of graphics (geoms, aesthetics, stats, and faceting) using the ggplot2 package to create plots layer-by-layer. 

This lesson assumes a basic familiarity with R, data frames, and manipulating data with tidyr, dplyr and the pipe `%>%`.

In this session, we will use the following packages:
- tidyverse 
- or readr, dplyr, & ggplot2

```{r lib}
library(tidyverse)
```

### Download data and skeleton script from GitHub into project
Go to GitHub [repo](https://github.com/mariekekjones/BIMS-bootcamp) to get these materials

### NHANES data

The data we're going to work with comes from the National Health and Nutrition Examination Survey (NHANES) program at the CDC. You can read a lot more about NHANES on the [CDC's website](http://www.cdc.gov/nchs/nhanes/) or [Wikipedia](https://en.wikipedia.org/wiki/National_Health_and_Nutrition_Examination_Survey). 

NHANES is a research program designed to assess the health and nutritional status of adults and children in the United States. The survey is one of the only to combine both survey questions and physical examinations. It began in the 1960s and since 1999 examines a nationally representative sample of about 5,000 people each year. The NHANES interview includes demographic, socioeconomic, dietary, and health-related questions. The physical exam includes medical, dental, and physiological measurements, as well as several standard laboratory tests. NHANES is used to determine the prevalence of major diseases and risk factors for those diseases. NHANES data are also the basis for national standards for measurements like height, weight, and blood pressure. Data from this survey is used in epidemiology studies and health sciences research, which help develop public health policy, direct and design health programs and services, and expand the health knowledge for the Nation.

We are using a small slice of this data. We're only using a handful of variables from the 2011-2012 survey years on about 5,000 individuals. The CDC uses a [sampling strategy](http://www.cdc.gov/nchs/data/series/sr_02/sr02_162.pdf) to purposefully oversample certain subpopulations like racial minorities. Naive analysis of the original NHANES data can lead to mistaken conclusions because the percentages of people from each racial group in the data are different from general population. The 5,000 individuals here are resampled from the larger NHANES study population to undo these oversampling effects, so you can treat this as if it were a simple random sample from the American population.

Let's read in the data to an object called `nh` and take a look with `View`. Remember, we need to load both the dplyr and readr packages (or tidyverse) for efficiently reading in and displaying this data.

```{r readNH}

# Read in downloaded data using readr package
nh <- read_csv(file="nhanes.csv")

# Show the first few lines of the data and the dimensions
nh

# Optionally bring up data in a viewer window.
# View(nh)
```

This particular excerpt has 5000 observations of 32 variables

### dplyr review

For those of you who were here for the Intro session yesterday, this will be a review. For those of you new to the tidyverse, this is exciting stuff!

The dplyr package gives you a handful of useful **verbs** for managing data. On their own they don't do anything that base R can't do. Here are some of the _single-table_ verbs we'll cover briefly in this lesson (single-table meaning that they only work on a single table -- contrast that to _two-table_ verbs used for joining data together). They all take a `data.frame` or `tbl` as their input for the first argument, and they all return a `data.frame` or `tbl` as output.

Show how to access dplyr cheat sheet from `Help` menu

1. `filter()`: filters _rows_ of the data where some condition is true
1. `group_by()`: groups a data frame by one or more variable. Most data operations are useful done on groups defined by variables in the the dataset. The `group_by` function takes an existing data frame and converts it into a grouped data frame where `summarize()` operations are performed _by group_.
1. `summarize()`: summarizes multiple values to a single value, most useful when combined with `group_by()`

dplyr takes a tibble dataframe as its first argument and then a logical condition to meet as the second argument.

- `==`: Equal to
- `!=`: Not equal to
- `>`, `>=`: Greater than, greater than or equal to
- `<`, `<=`: Less than, less than or equal to

If you want to satisfy *all* of multiple conditions, you can use the "and" operator, `&`. The "or" operator `|` (the pipe character, usually shift-backslash) will return a subset that meet *any* of the conditions.

Let's use filter to return rows where the person was elderly (defined as >= 80 years old)

```{r children}
filter(nh, Age >= 80)
```

The dplyr package also imports functionality from the [magrittr](https://github.com/smbache/magrittr) package that lets you _pipe_ the output of one function to the input of another, so you can avoid nesting functions. It looks like this: **`%>%`**. You don't have to load the magrittr package to use it since it is part of dplyr too.

Here's the simplest way to use the pipe. Remember the `head()` function. It expects a data frame as input, and the next argument is the number of lines to print. These two commands are identical:

```{r headpipe}
head(nh, 5)
nh %>% head(5)
```

Now let's use the pipe operator with filter

```{r filterpipe}
filter(nh, Age >= 80) #without pipe
nh %>% filter(Age >= 80) #pipe!
```

### Nesting v. %>%

Let's say we want to see the mean BMI, grouped by SmokingStatus, only for adults.

The way you do this without pipes is completely inside-out and backwards from the way you express in words and in thought what you want to do. Because the arguments belonging to a function get pushed farther and father away from the function name as you add more nesting elements, that results in messy, unreadable code. 
```{r wo pipe}
summarize(group_by(filter(nh, Age >= 18), SmokingStatus), meanBMI=mean(BMI, na.rm = TRUE))
```

Compare this code with the mental process of what you're actually trying to accomplish. 

Really what we want to do:
1. take nh THEN
1. filter for adults THEN
1. group_by SmokingStatus THEN
1. summarize mean BMI and remove NAs

The pipe operator `%>%` allows us to group the arguments with their function and order the functions in the same order as we want to do them. In this way we can pass the output tibble from one function to the input tibble of the next function.

```{r w pipe}
nh %>%
  filter(Age >= 18) %>%
  group_by(SmokingStatus) %>%
  summarize(meanBMI = mean(BMI, na.rm = TRUE))
```

** YOUR TURN **
** EXERCISE 1 **
A. How many observations are there of children (< 18 years old)?
B. How many cases of obese children are there (BMI >= 30)?
C. Use `filter()` followed by `group_by()` and `summarize()` to find the mean BMI by Smoking Status for only people who have Diabetes. Do smokers or non-smokers have higher BMI?

```{r ex1}
#A
nh %>% 
  filter(Age < 18)

#B
nh %>% 
  filter(Age < 18 & BMI >= 30)

#C
nh %>%
  filter(Diabetes == "Yes") %>%
  group_by(SmokingStatus) %>%
  summarize(meanBMI = mean(BMI, na.rm = TRUE))
```

Alternatively to answer C, you could have grouped by both Smoking Status and Diabetes to answer this question
```{r}
nh %>%
  group_by(SmokingStatus, Diabetes) %>%
  summarize(meanBMI = mean(BMI, na.rm = TRUE))
```

Let's make some plots to examine the relationships between variables. We will be plotting using ggplot2

### About ggplot2

**ggplot2** is a widely used R package that extends R's visualization capabilities. It takes the hassle out of things like creating legends, mapping other variables to scales like color, or plotting multiple small plots together.

_Where does the "gg" in ggplot2 come from?_ The **ggplot2** package provides an R implementation of Leland Wilkinson's *Grammar of Graphics* (1999). The *Grammar of Graphics* allows you to think beyond the garden variety plot types (e.g. scatterplot, barplot) and the consider the components that make up a plot or graphic, such as how data are represented on the plot (as lines, points, etc.), how variables are mapped to coordinates or plotting shape or color, what transformation or statistical summary is required, and so on. 

Specifically, **ggplot2** allows you to build a plot layer-by-layer by specifying:

- a **geom**, which specifies how the data are represented on the plot (points, lines, bars, etc.),
- **aesthetics** that map variables in the data to axes on the plot or to plotting size, shape, color, etc.,
- **facets**, which we've already seen above, that allow the data to be divided into chunks on the basis of other categorical or continuous variables and the same plot drawn for each chunk.

_First, a note about `qplot()`._ The `qplot()` function is a quick and dirty way of making ggplot2 plots. You might see it if you look for help with ggplot2, and it's even covered extensively in the ggplot2 book. And if you're used to making plots with built-in base graphics, the `qplot()` function will probably feel more familiar. But the sooner you abandon the `qplot()` syntax the sooner you'll start to really understand ggplot2's approach to building up plots layer by layer. So we're not going to use it at all in this class.

See [R Graphics Cookbook](http://www.cookbook-r.com/Graphs/) for more help with ggplot2.

### Scatterplots
Age (X) against Height (Y) (continuous X, continuous Y)
```{r}
nh %>%
  ggplot(aes(x = Age, y = Height)) #what happened...why?

nh %>%
  ggplot(aes(x = Age, y = Height)) + geom_point()

#color the points by Gender
nh %>%
ggplot(aes(x= Age, y = Height)) + 
  geom_point(aes(color = Gender))

#color the points blue and shape them as +
nh %>%
ggplot(aes(x= Age, y = Height)) + 
  geom_point(color = "blue", shape = 3)

#what is the difference between coloring by a variable and coloring by static values
#color the points by Gender (again)
nh %>%
ggplot(aes(x= Age, y = Height)) + 
  geom_point(aes(color = Gender))

#plot points colored by Gender and smoothed line
nh %>%
ggplot(aes(x= Age, y = Height)) +
  geom_point(aes(color = Gender)) + 
  geom_smooth() #both genders
```

By default `geom_smooth()` will try to lowess (Locally Weighted Scatterplot Smoothing) for data with n<1000 or GAM (Generalized Additive models) for data with n>1000. (In the geom_smooth help menu you can read all about these)

`geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = "cs")'. The s = smoothing function. bs = basis of smoothing and cs = cubic regression spines with shrinkage

We can change the geom_smooth() behavior by tweaking the parameters to color by Gender and use a LOESS instead of a GAM.
```{r}
#plot smoothed trend line and points both colored by gender
nh %>%
ggplot(aes(x= Age, y = Height)) +
  geom_point(aes(color = Gender)) + 
  geom_smooth(aes(color = Gender), method = "loess")

# color all layers by Gender
nh %>%
ggplot(aes(x= Age, y = Height, color = Gender)) +
  geom_point() + 
  geom_smooth(method = "loess")

# color all layers by Gender, add transparency to points, make line bolder
nh %>%
ggplot(aes(x= Age, y = Height, color = Gender)) +
  geom_point(alpha = .2) + 
  geom_smooth(method = "loess", lwd = 2)
```

### Visualizations for discrete X

Above we were plotting a continuous X and a continuous Y. For visualizations with discrete X variables and continuous Y, boxplots will be shown instead of scatterplots.

Let's look at BMI by Smoking Status
```{r boxplot}
#blank canvas, note categories on X
nh %>%
  ggplot(aes(x = SmokingStatus, y = BMI))

#try with geom point
nh %>%
  ggplot(aes(x = SmokingStatus, y = BMI)) + geom_point()
# no variability in X values --> overplotting

# so add some variability
nh %>%
  ggplot(aes(x = SmokingStatus, y = BMI)) + geom_jitter()
```

Note that the little bit of horizontal noise that's added to the jitter is random. If you run that command over and over again, each time it will look slightly different. The idea is to visualize the density at each vertical position, and spreading out the points horizontally allows you to do that. If there were still lots of over-plotting you might think about adding some transparency by setting the `alpha=` value for the jitter.

```{r}
# remove NA category and add transparency
nh %>%
  filter(!is.na(SmokingStatus)) %>%
  ggplot(aes(x = SmokingStatus, y = BMI)) + geom_jitter(alpha = .25)
```

Probably a more common visualization for a discrete X is to show a box plot:
```{r}
# categorical data can be plotted using boxplots
nh %>%
  filter(!is.na(SmokingStatus)) %>%
  ggplot(aes(x = SmokingStatus, y = BMI)) + 
  geom_boxplot()
```

Why not try visualizing both the underlying data (jitter) and the summary (boxplot)
```{r}
nh %>%
  filter(!is.na(SmokingStatus)) %>%
  ggplot(aes(x = SmokingStatus, y = BMI)) + 
  geom_jitter(alpha = .25) +
  geom_boxplot()
```

What can we do to improve the above plot?

```{r}
#need to make boxplot transparent and deal with fact that outliers will be plotted twice, once per layer
nh %>%
  filter(!is.na(SmokingStatus)) %>%
  ggplot(aes(x = SmokingStatus, y = BMI)) + 
  geom_jitter(alpha = .25) +
  geom_boxplot(alpha = .5, outlier.colour = NA)
```

### Choosing colors and themes

```{r}
#just boxplot colored by Diabetes
nh %>%
  filter(!is.na(SmokingStatus)) %>%
  ggplot(aes(x = SmokingStatus, y = BMI)) + 
  geom_boxplot(aes(fill = Diabetes))

#change colors manually
nh %>%
  filter(!is.na(SmokingStatus)) %>%
  ggplot(aes(x = SmokingStatus, y = BMI)) + 
  geom_boxplot(aes(fill = Diabetes)) +
  scale_fill_manual(values = c("cornflowerblue", "coral1"))

#change theme
nh %>%
  filter(!is.na(SmokingStatus)) %>%
    ggplot(aes(x = SmokingStatus, y = BMI)) + 
  geom_boxplot(aes(fill = Diabetes)) +
  scale_fill_manual(values = c("cornflowerblue", "coral1")) +
  theme_bw()

#experiment with colors and themes
#save basic plot as letter
p <- nh %>%
  filter(!is.na(SmokingStatus)) %>%
  ggplot(aes(x = SmokingStatus, y = BMI, fill = Diabetes)) + geom_boxplot()
p

colors()

p + theme_bw()

p + theme_classic() + scale_fill_manual(values = c("turquoise2", "violetred"))
```

** YOUR TURN **
** EXERCISE 2 **
### break this exercise into 2, one for scatterplots and one for boxplots
A. Use a scatterplot to investigate the relationship between Age and Testosterone for men between 65 and 80 years old.
B. Does the relationship you saw in A differ if the man is physically active (PhysActive == "Yes")? Use colored loess lines to see the effect of physical activity.
C. Create a plot showing the relationship between RelationshipStatus and the Number of Alcoholic drinks yearly (`AlcoholYear`) for adults. Optionally, color by Gender.
```{r}
#A
nh %>%
  filter(Gender == "male" & Age > 65 & Age < 80) %>%
  ggplot(aes(x = Age, y = Testosterone)) + 
  geom_point()

#B
nh %>%
  filter(Gender == "male" & Age > 65 & Age < 80) %>%
  ggplot(aes(x = Age, y = Testosterone)) + 
  geom_point() + 
  geom_smooth(aes(color = PhysActive))

#C
nh %>%
  ggplot(aes(x = RelationshipStatus, y = AlcoholYear)) + geom_boxplot()

#C with color
nh %>%
  ggplot(aes(x = RelationshipStatus, y = AlcoholYear, fill = Gender)) + geom_boxplot()
```

---- HERE is where I am currently editing. Above is done. Below is not ----

### Faceting

Facets display subsets of the data in different panels. There are a couple ways to do this, but `facet_wrap()` tries to sensibly wrap a series of facets into a 2-dimensional grid of small multiples. Just give it a formula specifying which variables to facet by. We can continue adding more layers, such as smoothing. If you have a look at the help for `?facet_wrap()` you'll see that we can control how the wrapping is laid out.

```{r scatter_facet1}
#start with basic plot canvas saved as letter
m <- nh %>%
  ggplot(aes(x= Age, y = Height))
m

#add points colored by gender to canvas
m + geom_point(aes(color = Gender))

#facet by race
m + geom_point(aes(color = Gender)) +
  facet_wrap(~ Race)
```


**EXERCISE practicing reproducing plots from pictures**

A. Here
B. Here

```{r ex}

```

1. **Bonus**: using `geom_line()` and an aesthetic mapping `country` to `group=`, make a "spaghetti plot", showing _semitransparent_ lines connected for each country, faceted by continent. Add a smoothed loess curve with a thick (`lwd=3`) line with no standard error stripe. Reduce the opacity (`alpha=`) of the individual black lines. _Don't_ show Oceania countries (that is, `filter()` the data where `continent!="Oceania"` before you plot it).
```{r spaghetti, echo=FALSE, eval=TRUE, fig.keep="last", fig.width=8}
p <- ggplot(filter(gm, continent!="Oceania"), aes(year, lifeExp))
#p + facet_wrap(~continent) + geom_line()
#p + facet_wrap(~continent) + geom_line(aes(group=country))
p + facet_wrap(~continent) + geom_line(aes(group=country), alpha=.5) + geom_smooth(lwd=3, se=FALSE)
```

### Plotting univariate continuous data

What if we just wanted to visualize distribution of a single continuous variable? A histogram is the usual go-to visualization. Here we only have one aesthetic mapping instead of two.

```{r init_histogram, eval=TRUE}
p <- ggplot(gm, aes(lifeExp))
```

```{r}
p + geom_histogram()
```

When we do this ggplot lets us know that we're automatically selecting the width of the bins, and we might want to think about this a little further.

```{r}
p + geom_histogram(bins=30)
p + geom_histogram(bins=10)
p + geom_histogram(bins=200)
```

```{r histogram, eval=TRUE, fig.keep="last"}
p + geom_histogram(bins=60)
```

Alternatively we could plot a smoothed density curve instead of a histogram:

```{r}
p + geom_density()
```

Back to histograms. What if we wanted to color this by continent?

```{r}
p + geom_histogram(aes(color=continent))
```

That's not what we had in mind. That's just the outline of the bars. We want to change the _fill_ color of the bars.

```{r}
p + geom_histogram(aes(fill=continent))
```

Well, that's not exactly what we want either. If you look at the help for `?geom_histogram` you'll see that by default it stacks overlapping points. This isn't really an effective visualization. Let's change the position argument.

```{r}
p + geom_histogram(aes(fill=continent), position="identity")
```

But the problem there is that the histograms are blocking each other. What if we tried transparency? Faceting?

```{r}
p + geom_histogram(aes(fill=continent), position="identity", alpha=1/3)
```

That's somewhat helpful, and might work for two distributions, but it gets cumbersome with 5.
Try faceting:

```{r}
p + geom_histogram() + facet_wrap(~continent)
```

Let's go back and try this with density plots, first changing the color of the line:

```{r}
p + geom_density(aes(color=continent), lwd = 2)
```

Then by changing the color of the fill and setting the transparency to 25%:

```{r densityplot, eval=TRUE, fig.keep="last"}
p + geom_density(aes(fill=continent), alpha=1/4)
```


----

**EXERCISE `r .ex``r .ex=.ex+1`**

1. Plot a histogram of GDP Per Capita.
1. Do the same but use a log<sub>10</sub> x-axis.
1. Still on the log<sub>10</sub> x-axis scale, try a density plot mapping continent to the fill of each density distribution, and reduce the opacity.
1. Still on the log<sub>10</sub> x-axis scale, make a histogram faceted by continent _and_ filled by continent. Facet with a single column (see `?facet_wrap` for help). 
1. Save this figure to a 6x10 PDF file.

```{r, echo=FALSE, eval=FALSE}
p <- ggplot(gm, aes(gdpPercap))
p + geom_histogram()

p <- p + scale_x_log10()
p + geom_histogram()
p + geom_density(aes(fill=continent), alpha=1/4)
p + geom_histogram(aes(fill=continent)) + facet_wrap(~continent, ncol=1)
ggsave("myplot.pdf", width=6, height=10)
```

### Analysis

```{r}
#create factor variables
nh <- nh %>%
  mutate_if(is.character, as.factor)
nh

levels(nh$Race)
```


### T-tests 
T-tests analyze the difference in 2 group means

Let's say we want to analyze the difference in height between males and females

Assumptions of t-test and how to assess
1. random sampling-- met
1. independent samples -- met
1. equal variance -- ?
1. normality -- ?

Assessing normality and equal variance in one plot
```{r}
#create overlapping density plots of height colored by gender
nha %>%
  ggplot(aes(Height)) + geom_density(aes(fill = Gender, alpha = .5))

#normality is best assessed using a qq plot
males <- nha %>% filter(Gender == "male")
females <- nha %>% filter(Gender == "female")
qqnorm(males$Height, pch = 16)
qqnorm(females$Height, pch = 16)
qqline(females$Height)

#shapiro wilk test of normality
shapiro.test(males$Height)
shapiro.test(females$Height)

#ks.test = Kolmogorov-Smirnov
```

Now that we know what test to run, run it

```{r}
# equal variance, independent samples t-test
?t.test()
t.test(Height ~ Gender, data = nha, var.equal = TRUE)
```

What to do if normality assumption is not met? What about equal var?

```{r}
#Exercise 2
# is there a difference in AlcoholYear by relationship status?

nha %>%
  filter(RelationshipStatus != "NA") %>%
  ggplot(aes(AlcoholYear)) + geom_density(aes(fill = RelationshipStatus, alpha = .3))

#based on plots, do wilcox
wilcox.test(AlcoholYear ~ RelationshipStatus, data = nha)

?wilcox.test

#calculate median for each group
nha %>%
  group_by(RelationshipStatus) %>%
  summarize(median(AlcoholYear, na.rm = TRUE))

nha %>%
  group_by(RelationshipStatus) %>%
  summarize(mean(AlcoholYear, na.rm = TRUE))
```

```{r}
#############
#ANOVA and LM

#BMI and relationship status
t.test(BMI ~ RelationshipStatus, data = nha, var.equal = TRUE)

#same question as a linear model
fit <- lm(BMI ~ RelationshipStatus, data = nha)
fit
anova(fit) #running an ANOVA
summary(fit)

#############
#ANOVA with 3 groups
#BMI by smoking status

levels(nha$SmokingStatus)

fit <- lm(BMI ~ SmokingStatus, data = nha)
anova(fit)
summary(fit)

#change reference category to Never
nha$SmokingStatus <- factor(nha$SmokingStatus, levels = c("Never", "Former", "Current"))

levels(nha$SmokingStatus)

fit <- lm(BMI ~ SmokingStatus, data = nha)
anova(fit)
summary(fit)

#check out Tukey's multiple comparisons
TukeyHSD(aov(fit))

###show results
nha %>%
  ggplot(aes(SmokingStatus, BMI)) + geom_boxplot()

###### Linear model with 2 continuous variables
#Weight ~ Height
fit <- lm(Weight ~ Height, data = nha)
summary(fit)
#for each 1 cm increase in Height, we have a .92 kg increase in weight

#plot these results
nha %>%
  ggplot(aes(Height, Weight)) + geom_point() + geom_smooth(method = "lm")

###assumptions of linear model
#random sampling
# x and y are related by a a straight line
#residuals are independent
# normality of residuals
# equal variance of residuals (variance is constant across X)
plot(fit)

######
#Multiple regression
#Testosterone ~ PhysActive

fit <- lm(Testosterone ~ PhysActive, data = nha)
summary(fit)

# add in Age
fit <- lm(Testosterone ~ PhysActive + Age, data = nha)
summary(fit)

#add in Gender
fit <- lm(Testosterone ~ PhysActive + Age + Gender, data = nha)
summary(fit)

##########################
#Exercise 3
# Income ~ Work
fit <- lm(Income ~ Work, data = nha)
fit
#anova
anova(fit)

#Tukey
plot(TukeyHSD(aov(fit)))

#summary()
summary(fit)
```

Obviously need to cut lots to get to 3 hours. Don't worry!